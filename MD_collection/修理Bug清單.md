# SR 保活重啟延遲修理 Bug 清單

> 目標：當本地語音辨識（SR）長時間無結果時，將重啟觸發的延遲從目前的 20 秒，縮短為「無結果滿 4 秒後重啟」，並確保不會造成重啟風險。

## 背景與現況
- 目前保活邏輯在 `js/presentation.js` 的 `startSrKeepAlive()` 中，使用：
  - `SR_KEEPALIVE_QUIET_MS = 20000`（20 秒無結果判定卡住）
  - `SR_KEEPALIVE_CHECK_MS = 5000`（每 5 秒檢查一次）
- 當判定卡住時，程式會先提交暫時文字、呼叫 `sr.stop()`，並由 `sr.onend` 走重啟序。

## 修理項目
- [x] 將 `SR_KEEPALIVE_QUIET_MS` 調整為 `4000`（4 秒）
- [x] 將 `SR_KEEPALIVE_CHECK_MS` 調整為 `500–1000`（建議 `1000`），以保證在 ~4 秒左右檢出
- [x] 確認所有結果事件（`sr.onresult` 的 interim 與 final）都有更新 `lastSrResultTs`（目前已有，需回歸測）
- [x] 觸發保活重啟時，保留現有「先提交暫時文字再 `sr.stop()`」的行為，避免文本遺失
- [x] 日誌調整：將訊息改為 `🧰 SR保活: 4秒無結果，觸發重啟`，便於追蹤
- [x]（選擇性）新增本地 SR 保活的「重啟冷卻」機制（例如 `MIN_SR_RESTART_INTERVAL_MS = 1500–2000`），避免在邊界情況下頻繁重啟
- [ ]（選擇性）同步檢討遠端保活 `startHeartbeat()`：如需一致行為，將 `heartbeatQuietMs` 調整為 4–6 秒並保留冷卻

## 變更檔案
- `js/presentation.js`
  - 常數：`SR_KEEPALIVE_QUIET_MS`、`SR_KEEPALIVE_CHECK_MS`
  - 函式：`startSrKeepAlive()`、`sr.onresult`、`sr.onend`
  -（選擇性）`startHeartbeat()` 的 `heartbeatQuietMs`

## 實作要點
- 「4 秒無結果」以 `Date.now() - lastSrResultTs >= 4000` 判定
- 檢查間隔建議 `1000ms`，確保最差延遲 ≈ 5 秒（含一次檢查週期）
- 與既有的自動重啟（`AUTO_RESTART_DELAY_MS = 2000`）與靜音監測互斥：
  - 有活動時呼叫 `updateActivityTime()` 即停止自動重啟計時器
  - 保活重啟優先於靜音自動重啟；觸發後重設活動時間

## 驗收標準（Definition of Done）
- 無結果持續 4 秒（±1 秒檢查誤差）時，能在 ≈5 秒內觸發重啟
- 觸發前的暫時文字能正確提交，不遺失
- 在長時間背景靜音（> 60 秒）下，不會頻繁重啟（如啟用冷卻）
- 與遠端 STT 心跳互不干擾；停止錄音時能正確清除所有計時器
- DevTools 日誌可見：`🧰 SR保活: 4秒無結果，觸發重啟`

## 測試建議
1. 正常說話 → 暫停 4.2 秒 → 觀察是否重啟並且最新暫時文字被提交
2. 連續兩次短暫靜音（3.8–4.2 秒）→ 確認不會形成重啟風暴（若啟用冷卻，至少間隔 1.5–2 秒）
3. 啟用遠端 STT → 停止訊息流 → 檢查本地保活是否不受影響（或按需求同步調整）
4. 使用不支援 SR 的瀏覽器（或阻擋權限）→ 確認不會崩潰，並有合理錯誤訊息

## 風險與回滾方案
- 風險：在某些瀏覽器實作上 4 秒可能仍偏緊 → 以冷卻間隔與日誌觀察調整
- 回滾：若影響使用體驗，將 `QUIET_MS` 調回 5000–10000 並保留較短檢查間隔

---
> 追蹤：完成後在 `待辦清單.md` 標記為已修復，並附上最終採用的毫秒值與測試截圖。